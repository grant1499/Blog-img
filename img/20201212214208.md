#### 1.线性表的顺序存储结构

```c
#define MAXSIZE 20    
typedef int ElemType;
typedef struct
{
ElemType elem[MAXSIZE];//存储空间
int length;    // 线性表当前长度
} SqList;//俗称顺序表
//线性表顺序存储结构代码

//方案二
#define  LIST_INIT_SIZE     80  
                 // 线性表存储空间的初始分配量
#define  LISTINCREMENT    10 
                // 线性表存储空间的分配增量
typedef  struct {
    ElemType *elem;    // 存储空间基址
    int length;   // 当前长度
    int listsize;  // 当前分配的存储容量  
                             // (以sizeof(ElemType)为单位)
} SqList;  // 俗称 顺序表

```

##### **线性表的基本操作在顺序表中的实现**

```c
InitList(&L)  //结构初始化
LocateElem(L, e, compare())  //查找
ListInsert(&L,i, e)  //插入元素
ListDelete(&L,i,&e)  //删除元素
```

```c
//对顺序表结构初始化
Status InitList_Sq( SqList &L ) 
{
  // 构造一个空的线性表
	L.elem = (ElemType*) malloc (LIST_INIT_SIZE*sizeof (ElemType));
	if (!L.elem) exit(OVERFLOW);
	L.length = 0;
	L.listsize = LIST_INIT_SIZE
	return OK;
} // InitList_Sq
//时间复杂度为O(1)
```

```c
//对应P7线性表求集合A与B的并集操作
//La表示jiheA，Lb表示集合B
//将所有在线性表La中但不在Lb中的数据插入到La中
void unionL(List &La,List Lb)
{
    int La_len,Lb_len,i;
    
    ElemType e;
    La_len = ListLength(La);
    Lb_len = ListLength(Lb);
    
    for(i = 1;i<=Lb_len;i++)
    {
        GetElem(Lb,i,e);
        if(!LocateElem(La,e，equal))
        {
            ListInsert(La,++La_len,e);
        }
    }
}
```

```c
//对应P8获得元素操作
//实现GetElem
#define Ok 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

typedef int Status
//Status是函数的类型，其值是函数结果状态代码，如OK等
//初始条件：顺序线性表Sqlist L已经存在，1 <= i <= ListLength(L)
//操作结果：用e返回L中第i个数据元素的值
Status GetElem(Sqlist L,int i,ElemType &e)
{
	if(L.length == 0 || i<1 || i>L.length)
		return ERROR;
    e=L.dat[i-1];
    
    return OK;
}
//注意这里返回值类型Status是一个整型，约定返回值1代表OK，0代表ERROR
```

```cc
//对应P8插入操作
//实现ListInsert
/* 初始条件：顺序线性表L已存在，1<=i<=ListLength(L)。 */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L长度+1。*/

Status ListInsert(SqList &L, int i, ElemType e)
{
    int k;

    if( i<1 || i>L->length+1)   // 当i不在范围内时
    {
        return ERROR;
    }
    if( L.length == L.listsize )  // 顺序线性表已经满了
    {
        newbase = (ElemType*)realloc(L.elem(L.listsize+LISTINCREMENT)*sizeof(ElemType));
        if (newbase == NULL)exit(OVERFLOW);
    }
    L.elem = newbase;
    L.listsize += LISTINCREMENT;
        /* 将要插入位置后数据元素向后移动一位 */
        for( k=L.length; k >= i; k-- )
        {
            L.elem[k] = L.elem[k-1];
        }
    L.elem[i-1] = e;  // 将新元素插入
    L.length++;

    return OK;
}
//时间复杂度为O(n),按平均值
```

```c
//对应P9删除操作
//实现ListDelete
/* 初始条件：顺序线性表L已存在，1<=i<=ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度-1 */
Status ListDelete(SqList &L, int i, ElemType &e)
{

    if( L.length == 0 )
    {
        return ERROR;
    }
    if( i<1 || i>L.length )
    {
        return ERROR;
    }
    p = &(L.elem[i-1]);// p 为被删除元素的位置
    e = *p;// 被删除元素的值赋给 e
	q = L.elem + L.lengh-1;// 表尾元素的位置
        for( ++q;p <= q;++p )
        {
            *(p-1) = *p;
        }
    --L.length;

    return OK;
}
//时间复杂度为O(n)
```

##### 关于顺序线性表的优缺点

###### •优点：

–无须为表示表中元素之间的逻辑关系而增加额外的存储空间。

–可以快速地存取表中任意位置的元素。

###### •缺点：

–插入和删除操作需要移动大量元素。

–当线性表长度变化较大时，难以确定存储空间的容量。 

–容易造成存储空间的“碎片”。

#### 2.线性表的链式存储结构

##### 单链表

```c
typedef struct LNode
{
    ElemType data;      // 数据域
    struct Node* Next;  // 指针域
}LNode,*LinkList;
LinkList L;//L为单链表的头指针
//单链表存储结构
//特别注意，在此之后的LinkList都是指向结构体的指针类型
```

```c
//对应P10获得元素操作
//实现GetElem
/* 初始条件：链式线性表L已存在，1<=i<=ListLength(L) */
/* 操作结果： 用e返回L中第i个数据元素的值 */
Status GetElem( LinkList L, int i, ElemType &e )
{
    int j;
    LinkList p;//p是一个指向节点的指针

    p = L->next;
    j = 1;

    while( p && j<i )
    {
        p = p->next; 
        ++j;
    }

    if( !p || j>i )
    {
        return ERROR;
    }

    e = p->data;

    return OK;
}
```

```c
//对应P11插入元素操作
//实现ListInsert
/* 初始条件：链式线性表L已存在，1<=i<=ListLength(L) */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */

Status ListInsert(LinkList &L, int i, ElemType e)
{
    int j;
    LinkList p, s;

    p = L;
    j = 0;

    while( p && j<i )   // 用于寻找第i个结点
    {
        p = p->next;
        ++j;
    }

    if( !p || j>i-1 )
    {
        return ERROR;
    }

    s = (LinkList)malloc(sizeof(LNode));
    s->data = e;

    s->next = p->next;
    p->next = s;//注意这里两句不能调换顺序

    return OK;
}

```

```c
//对应P11删除元素操作
//实现ListDelete
/* 初始条件：顺序线性表L已存在，1<=i<=ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度-1 */

Status ListDelete(LinkList &L, int i, ElemType &e)
{
    int j;
    LinkList p, q;

    p = L;
    j = 0;

    while( p->next && j<i-1 )
    {
        p = p->next;
        ++j;
    }

    if( !(p->next) || j>i-1 )
    {
        return ERROR;
    }

    q = p->next;
    p->next = q->next;//关键操作

    e = q->data;
    free(q);

    return OK;
}
```

```c
/* 头插法建立单链表示例 */
//对应P12头插法建立单链表
void CreateListHead(LinkList *L, int n)
{
    LinkList p;
    int i;

    srand(time(0));   // 初始化随机数种子

    *L = (LinkList)malloc(sizeof(Node));
    (*L)->next = NULL;//注意这里*L要加括号，因为*L才是一个指针，而L不是，LinkList *L

    for( i=0; i < n; i++ )
    {
        p = (LinkList)malloc(sizeof(Node));  // 生成新结点
        p->data = rand()%100+1;
        p->next = (*L)->next;
        (*L)->next = p;
    }
}

//课堂教学版本
void CreateListHead(LinkList &L, int n)
{
    LinkList p;
    int i;
    L = (LinkList)malloc(sizeof(Node));
    L->next = NULL;

    for( i=n; i>0; --i )
    {
        p = (LinkList)malloc(sizeof(Node));  // 生成新结点
        scanf(&p->data);//输入元素值
        p->next = L->next;
        L->next = p;
    }
}//CreateListHead
```

```c
/* 尾插法建立单链表演示 */
//对应P12尾插法建立单链表
void CreateListTail(LinkList *L, int n)
{
    LinkList p, r;
    int i;

    srand(time(0));
    *L = (LinkList)malloc(sizeof(Node));
    r = *L;

    for( i=0; i < n; i++ )
    {
        p = (Node *)malloc(sizeof(Node));
        p->data = rand()%100+1;
        r->next = p;
        r = p;                 // 备注：初学者可能很难理解这句，重点解释。
    }

    r->next = NULL;
}

//课堂教学版本
void CreateListTail(LinkList &L, int n)
{
    LinkList p, s;
    int bCycleFlag;
    L = (LinkList)malloc(sizeof(Node));//生成头结点
    if(L == NULL) exit(OVERFLOW);
    L->next = NULL;
	bCycleFlag = 1;//控制是否继续循环插入新结点
	p = L;//p为单链表的最后一个结点
    //循环插入新结点到最后一个结点*p之后
    while(bCycleFlag)
    {
        scanf(&c);// 输入待插的元素
        if (e != END_DATA)// END_DATA为标记元素输入结束的宏名
        {
            // 非结束元素，则插入到*p之后
            s = (LinkList)malloc(sizeof(Node));
            if(s == NULL) exit(OVERFLOW);
            s->data = e;
            s->next = p->next;
            p->next = s;
            p = s;// 修改最后一个结点的位置
		}
        else
        {
            bCycleFlag = 0;//设置循环插入结束
        }
        return OK;
	}
}
```

```c
//对应P13单链表整表删除(即置空)操作
//实现ClearList
Status ClearList(LinkList *L)
{
    LinkList p, q;

    p = (*L)->next;

    while(p)
    {
        q = p->next;
        free(p);
        p = q;
    }

    (*L)->next = NULL;

    return OK;
}

//课堂教学版本
void ClearList(LinkList &L)
{
    LinkList p;
    while(L->next)
    {
        p = L->next;
        L->next = p->next;
        free(p);
	}
}
```

# 补充：如何理解数据结构中*和&的区别

```
在定义时，*是一个标识符，声明该变量是一个指针，比如说int *p; 那p就是一个指向int型的指针；
在调用时，*p是指指针p指向的那个变量，比如说之前有int a=5；int *p=a；那么p的值是a的地址，也就是指针p指向a，*p则等于a的值，即*p=5。
而&，则是引用，比如说有定义int a=5；再定义int b=&a；那么这里的b则引用a的值，即b=5
，而再给b赋值：b=10，a的值也会变为10。
我想楼主会问*和&的区别，应该是针对函数定义里的参数而言吧，因为这里的这两者比较相似：
举几个简单例子：
先定义有int x=0；和int *p=x；
1、若定义函数： void fun_1（int a）{ a=5；} ， 则调用：fun_1(x); 之后，x还等于0；因为fun_1函数只改变了形参a的值，a只是fun_1函数里的局部变量，调用fun_1(x)相当于是“a=x;a=5;”，x没变；
2、若定义函数：void fun_2（int &a）{ a=5；} ， 则调用：fun_2(x); 之后，x等于5；因为这里的a引用了x的值；
3、若定义函数：void fun_3（int *a）{ *a=5；} ， 则调用：fun_3(p); 之后，x也等于5；因为fun_3函数的参数a是一个指针，相当于a=p；*a则与*p指向同一地址，改变*a即改变*p即x


数据结构中*是取地址内容，和C语言用法一样。而&的用法有两种，一种是取地址运算符，和C语言的一样，另一种是引用，参考了C++的用法。

*有两个意思，一是定义指针时使用：int* p=pa；另一个是解引用时使用：cout<<*p<<endl。

&也有两个意思，一是取地址时使用：int* p=&a;另一个是定义引用时使用：int& a=b。

*&的意思是指针的引用，一般在函数的传参时使用，表示将指针直接传给函数，不是仅仅复制指针的地址作为副本进行传递。
```

